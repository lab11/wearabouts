<!DOCTYPE html>
<meta charset="utf-8">
<style>

.link {
    stroke: #999;
}

.node_circle {
    stroke-width: 1.5px;
}

.label {
    font-family: "Droid Sans", "Tahoma", "sans-serif";
}

.back-img {
    opacity: 0.25;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="socket.io.min.js"></script>
<script>

var width = 1300;
var height = 600;
var uuid = 0;
var init_complete = false;

/*
// clarkKerr_simple_900_700.png
var foci = [
    {x: 250, y: 175},
    {x: 380, y: 390},
    {x: 600, y: 175},
    {x: 355, y: 700},
    {x: 575, y: 620}];
*/
// clarkKerr_simple_1100_500.png
var foci = [
    {x: 250, y: 200},
    {x: 440, y: 420},
    {x: 600, y: 200},
    {x: 875, y: 325},
    {x: 1100, y: 200}];

var select_color = d3.scale.category10();

var center_nodes = [];
init_nodes();

var force = d3.layout.force()
    .size([width, height])
    .nodes(center_nodes.slice(0)) // need to 
    .linkStrength(0.9)
    .linkDistance(function(d) { return d.confidence; })
    .charge(-250)
    .chargeDistance(100)
    .gravity(0)
    .friction(0.8)
    .on("tick", tick);

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

var grad = svg.append("defs").append("radialGradient")
        .attr("id", "label_gradient")

grad.append("stop")
    .attr("offset", "20%")
    .attr("stop-color", "#FFFFFF")
    .attr("stop-opacity", 0.8)

grad.append("stop")
    .attr("offset", "100%")
    .attr("stop-color", "#FFFFFF")
    .attr("stop-opacity", 0)

svg.style("opacity", 1e-6)
    .transition()
    .duration(1000)
    .style("opacity", 1);

/*
svg.append("image")
    .attr("class", "back-img")
    .attr("xlink:href", 'clarkKerr_simple_1100_500.png')
    .attr("x", 125)
    .attr("y", 25)
    .attr("width", 1100)
    .attr("height", 500)
    */
svg.append("image")
    .attr("class", "back-img")
    .attr("xlink:href", 'clarkKerr_simple_1100_500.png')
    .attr("x", 125)
    .attr("y", 50)
    .attr("width", 1100)
    .attr("height", 500)

svg.append("image")
    .attr("xlink:href", "whereaboutsLogo.png")
    .attr("width", 610)
    .attr("height", 40)
    .attr("x", 200)
    .attr("y", 10)

restart();
init_complete = true;

var gatd_socket;
onload = function() { 
    gatd_socket = io.connect('inductor.eecs.umich.edu:8082/stream');
    gatd_socket.on('connect', function(data) {
        // query starting immediately
        gatd_socket.emit('query', {'profile_id': '62MTxDGPhJ'});
        });
    gatd_socket.on('data', function(data) {
            parse_data(data)});
}

function init_nodes( ) {
    var i=0;
    for (i=0; i<foci.length; i++) {
        center_nodes.push({x: foci[i].x, y: foci[i].y, fixed: 1, foci_id: i, name: i});
        uuid++;
    }
}

function addOrUpdateNode(name, confidence, foci_id) {
    var nodes = force.nodes();
    node_index = -1;
    for (var i=0; i<nodes.length; i++) {
        if (nodes[i].name == name) {
            node_index = i;
            break;
        }
    }

    if (node_index == -1) {
        // node doens't exist and must be added
        addNode(name, confidence, foci_id);
        return;
    }

    // node exists and should be updated
    force.nodes()[i].foci_id = foci_id;

    var links = force.links();
    for (var i=0; i<links.length; i++) {
        if (links[i].name == name) {
            force.links()[i].target = center_nodes[foci_id];
            force.links()[i].confidence = convertConfidence(confidence);
            break;
        }
    }

    restart();
}


function addNode(name, confidence, foci_id) {
    if (!init_complete) {
        var node = {id: uuid, name: name, foci_id: foci_id};
    } else {
        var node = {id: uuid, x: foci[foci_id].x, y: foci[foci_id].y, name:name, foci_id: foci_id};
    }
    var link = {source: node, target: center_nodes[foci_id], name: name, confidence: convertConfidence(confidence)};
    uuid++;

    force.nodes().push(node);
    force.links().push(link);

    restart();
}

function moveNode(name, confidence, foci_id) {
    var nodes = force.nodes();
    for (var i=0; i<nodes.length; i++) {
        if (nodes[i].name == name) {
            force.nodes()[i].foci_id = foci_id;
            break;
        }
    }

    var links = force.links();
    for (var i=0; i<links.length; i++) {
        if (links[i].name == name) {
            force.links()[i].target = center_nodes[foci_id];
            force.links()[i].confidence = convertConfidence(confidence);
            break;
        }
    }

    restart();
}

function removeNode(name) {
    var nodes = force.nodes();
    var node_index = -1;
    for (var i=0; i<nodes.length; i++) {
        if (nodes[i]['name'] == name) {
            force.nodes().splice(i, 1);
            node_index = i;
            break;
        }
    }

    // node doesn't exist, stop bothering
    if (node_index == -1) {
        return;
    }

    var links = force.links();
    for (var i=0; i<links.length; i++) {
        if (links[i]['name'] == name) {
            force.links().splice(i, 1);
            break;
        }
    }

    restart();
}

function nodeExists(name) {
    var nodes = force.nodes();
    for (var i=0; i<nodes.length; i++) {
        if (nodes[i].name == name) {
            return true;
        }
    }

    return false;
}

function convertConfidence(confidence) {
    return 1.0*(confidence*100);
}

function tick(e) {
    link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    // create artificial gravity towards foci
    var k = 0.1*e.alpha;
    force.nodes().forEach(function(d, i) {
            if (!d.fixed) {
                d.y += (foci[d.foci_id].y - d.y)*k;
                d.x += (foci[d.foci_id].x - d.x)*k;
            }});

    // run collision detection
    if (init_complete) {
        var q = d3.geom.quadtree(force.nodes());
        for (var i=0; i<force.nodes().length; i++) {
            q.visit(collide(force.nodes()[i]));
        }
    }

    node.attr("x", function(d) {
            if (!d.fixed) { return d.x - d.text.getBBox().width/2; }
            else { return d.x - 1; }})
        .attr("y", function(d) {
            if (!d.fixed) { return d.y - d.text.getBBox().height/2; }
            else { return d.y - 1; }})
        .attr("width", function(d) {
            if (!d.fixed) { return (d.text.getBBox().width+4); }
            else { return 2; }})
        .attr("height", function(d) {
            if (!d.fixed) { return (d.text.getBBox().height+4); }
            else { return 2; }});
    text.attr("x", function(d) { return d.x + 2; })
        .attr("y", function(d) { return d.y + (d.text.getBBox().height/4) + 2; });
}

function collide(node) {

    if (node.fixed) {
        return function(quad, x1, y1, x2, y2) { return false; };
    }

    var h = node.text.getBBox().height+4+10,
        w = node.text.getBBox().width+4+10,
        nx1 = node.text.x - w/2,
        nx2 = node.text.x + w/2,
        ny1 = node.text.y - h/2,
        ny2 = node.text.y + h/2;

    return function(quad, x1, y1, x2, y2) {
        if (quad.point && quad.point.fixed) {
            return false;
        }
        if (quad.point && (quad.point !== node)) {
            var x = node.x - quad.point.x,
                y = node.y - quad.point.y,
                l = Math.sqrt(x * x + y * y),
                r = (node.text.getBBox().width+4 + quad.point.text.getBBox().width+4)/2;
            if (l < r) {
                l = (l - r) / l * .5;
                node.x -= x *= l;
                node.y -= y *= l;
                quad.point.x += x;
                quad.point.y += y;
            }
        }
        return x1 > nx2
            || x2 < nx1
            || y1 > ny2
            || y2 < ny1;
        };
}

function restart() {
    link = svg.selectAll(".link").data(force.links(), function(d) { return d.name; });
    link.enter().insert("line", ".node")
        .attr("class", "link")
        .style("opacity", 1);

    link.transition()
        .duration(500)
        .style("opacity", 1);

    link.exit()
        .transition()
            .duration(300)
            .style("opacity", 0)
            .remove();

    node = svg.selectAll("rect.node").data(force.nodes(), function(d) { return d.name; });
    node.enter().append("rect")
        .attr("class", "node")
        .attr("fill", function(d) {
            if (!d.fixed) { return 'url(#label_gradient)'; }
            //if (!d.fixed) { return select_color(d.id); }
            else { return 'black'; }})
        .attr("stroke", function(d) {
            if (!d.fixed) { return 'none'; }
            //if (!d.fixed) {return d3.rgb(select_color(d.id)).darker(2); }
            else { return 'black'; }})
        .attr("width", 0)
        .attr("height", 0)
        .attr("rx", 5)
        .attr("ry", 5)
        .style("opacity", 0);
    text = svg.selectAll("text").data(force.nodes(), function(d) { return d.name; });
    text.enter().append("text")
        .attr("class", "label")
        .attr("font-size", "14px")
        .attr("text-anchor", "middle")
        .text(function(d) {
            d['text'] = this; // this is a hack so I can access to the bounding box later
            if (!d.fixed) { return d.name; }
            else { return '';}})
        .style("opacity", 0);

    node.transition()
        .duration(500)
        .style("opacity", 1);
    text.transition()
        .duration(500)
        .style("opacity", 1);

    node.exit()
        .transition()
            .duration(300)
            .style("opacity", 0)
            .remove();
    text.exit()
        .transition()
            .duration(300)
            .style("opacity", 0)
            .remove();


    force.start();
}

function parse_data(data) {
    name = data['full_name'];
    confidence = data['confidence'];
    location_id = data['location_id'];

    // see if the node is in location 'None'
    if (location_id == -1) {
        // remove the node if it exists
        removeNode(name);
    } else {
        // add the node or update it if it exists
        addOrUpdateNode(name, confidence, location_id);
    }
}

</script>
